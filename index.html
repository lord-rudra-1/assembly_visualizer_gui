<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assembly Visualizer</title>
    <style>
        body {
            font-family: monospace;
            background-color: #222;
            color: #ddd;
            margin: 0;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .panel {
            background-color: #333;
            border: 1px solid #555;
            padding: 15px;
            border-radius: 5px;
            flex: 1;
            min-width: 300px;
        }
        .code-panel {
            min-height: 400px;
        }
        .highlight {
            color: yellow;
            font-weight: bold;
            background-color: rgba(255, 255, 0, 0.1);
        }
        .used {
            color: #6f6;
        }
        button {
            background-color: #444;
            color: white;
            border: 1px solid #666;
            padding: 8px 15px;
            margin: 10px 5px 10px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #555;
        }
        input, select, textarea {
            background-color: #444;
            color: white;
            border: 1px solid #666;
            padding: 8px;
            margin-bottom: 10px;
            border-radius: 4px;
            width: 100%;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
        }
        .register-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 5px;
        }
        h2 {
            margin-top: 0;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
        }
        pre {
            white-space: pre-wrap;
            margin: 0;
            overflow-y: auto;
            max-height: 380px;
        }
        .toolbar {
            margin-bottom: 20px;
        }
        .memory-display {
            max-height: 400px;
            overflow-y: auto;
        }
        .upload-area {
            border: 2px dashed #666;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
            cursor: pointer;
        }
        .footer {
            margin-top: 20px;
            text-align: center;
            font-size: 0.8em;
            color: #888;
        }
    </style>
</head>
<body>
    <h1>Assembly Visualizer</h1>
    
    <div class="toolbar">
        <button id="step-button">Step</button>
        <button id="reset-button">Reset</button>
        <button id="run-button">Run All</button>
        <button id="stop-button" disabled>Stop</button>
    </div>
    
    <div class="container">
        <!-- Code Panel -->
        <div class="panel code-panel">
            <h2>Assembly Code</h2>
            <div class="upload-area" id="upload-area">
                <p>Drag & drop assembly file or click to select</p>
                <input type="file" id="file-input" style="display: none;">
            </div>
            <div id="program-settings" style="display: none;">
                <label for="pc-start">Starting PC (hex):</label>
                <input type="text" id="pc-start" value="0x4000">
                
                <label for="pc-end">Ending PC (hex):</label>
                <input type="text" id="pc-end" value="0x7FFF">
                
                <label for="sp-start">Starting SP (hex):</label>
                <input type="text" id="sp-start" value="0xFF00">
                
                <button id="load-program">Initialize Program</button>
            </div>
            <pre id="code-display"></pre>
        </div>
        
        <!-- Register Panel -->
        <div class="panel">
            <h2>Registers</h2>
            <div class="register-grid" id="register-display"></div>
        </div>
        
        <!-- Memory Panel -->
        <div class="panel">
            <h2>Memory (Stack)</h2>
            <div class="memory-display" id="memory-display"></div>
        </div>
        
        <!-- Input Panel -->
        <div class="panel">
            <h2>User Input</h2>
            <div>
                <label for="input-type">Input Type:</label>
                <select id="input-type">
                    <option value="register">Register</option>
                    <option value="memory">Memory</option>
                </select>
                
                <div id="register-input-group">
                    <label for="reg-input">Register Number (0-32):</label>
                    <input type="text" id="reg-input" placeholder="Enter register number">
                </div>
                
                <div id="memory-input-group" style="display: none;">
                    <label for="mem-input">Memory Address (hex):</label>
                    <input type="text" id="mem-input" placeholder="0xAddress">
                </div>
                
                <label for="val-input">Value (decimal or hex):</label>
                <input type="text" id="val-input" placeholder="Value to set">
                
                <button id="set-value-button">Set Value</button>
            </div>
            
            <div style="margin-top: 20px;">
                <h3>Sample Assembly Program</h3>
                <textarea id="sample-program" rows="10">add x1, x0, #5      // Set x1 = 5
add x2, x0, #10     // Set x2 = 10
add x3, x1, x2      // Set x3 = x1 + x2 = 15
sub x4, x3, x1      // Set x4 = x3 - x1 = 10
lsl x5, x1, #2      // Set x5 = x1 << 2 = 20
lsr x6, x5, #1      // Set x6 = x5 >> 1 = 10
str x3, [sp, #-8]!  // Push x3 onto stack
ldr x7, [sp], #8    // Pop top of stack into x7
cmp x6, x4          // Compare x6 and x4
beq #12             // Branch if equal (should be taken)
add x8, x0, #99     // This should be skipped
add x9, x0, #42     // This should be skipped
add x10, x0, #255   // This should be skipped
add x8, x0, #1      // Set x8 = 1</textarea>
                <button id="load-sample">Load Sample</button>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p>Assembly Visualizer - Implementation of RISC-V assembly simulator with web interface</p>
    </div>
    
    <script>
        // Machine simulation
        const machine = {
            registers: new Array(33).fill(0),
            used: new Array(33).fill(false),
            stack: [],
            stack_bot: 0,
            stack_top: 0,
            code: [],
            code_start: 0,
            current_instruction: 0,
            running: false,
            runInterval: null
        };
        
        // UI References
        const codeDisplay = document.getElementById('code-display');
        const registerDisplay = document.getElementById('register-display');
        const memoryDisplay = document.getElementById('memory-display');
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('file-input');
        const programSettings = document.getElementById('program-settings');
        const pcStartInput = document.getElementById('pc-start');
        const pcEndInput = document.getElementById('pc-end');
        const spStartInput = document.getElementById('sp-start');
        const loadProgramButton = document.getElementById('load-program');
        const stepButton = document.getElementById('step-button');
        const resetButton = document.getElementById('reset-button');
        const runButton = document.getElementById('run-button');
        const stopButton = document.getElementById('stop-button');
        const inputTypeSelect = document.getElementById('input-type');
        const registerInputGroup = document.getElementById('register-input-group');
        const memoryInputGroup = document.getElementById('memory-input-group');
        const regInput = document.getElementById('reg-input');
        const memInput = document.getElementById('mem-input');
        const valInput = document.getElementById('val-input');
        const setValueButton = document.getElementById('set-value-button');
        const sampleProgram = document.getElementById('sample-program');
        const loadSampleButton = document.getElementById('load-sample');
        
        // Event Listeners
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', e => {
            e.preventDefault();
            uploadArea.style.borderColor = '#aaa';
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.style.borderColor = '#666';
        });
        uploadArea.addEventListener('drop', e => {
            e.preventDefault();
            uploadArea.style.borderColor = '#666';
            
            if (e.dataTransfer.files.length) {
                handleFile(e.dataTransfer.files[0]);
            }
        });
        
        fileInput.addEventListener('change', () => {
            if (fileInput.files.length) {
                handleFile(fileInput.files[0]);
            }
        });
        
        loadProgramButton.addEventListener('click', initializeMachine);
        stepButton.addEventListener('click', stepExecution);
        resetButton.addEventListener('click', resetExecution);
        runButton.addEventListener('click', runExecution);
        stopButton.addEventListener('click', stopExecution);
        
        inputTypeSelect.addEventListener('change', () => {
            if (inputTypeSelect.value === 'register') {
                registerInputGroup.style.display = 'block';
                memoryInputGroup.style.display = 'none';
            } else {
                registerInputGroup.style.display = 'none';
                memoryInputGroup.style.display = 'block';
            }
        });
        
        setValueButton.addEventListener('click', setUserValue);
        loadSampleButton.addEventListener('click', loadSampleProgram);
        
        // Functions
        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = e => {
                machine.code = e.target.result.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0);
                
                codeDisplay.textContent = machine.code.join('\n');
                uploadArea.style.display = 'none';
                programSettings.style.display = 'block';
            };
            reader.readAsText(file);
        }
        
        function loadSampleProgram() {
            machine.code = sampleProgram.value.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);
            
            codeDisplay.textContent = machine.code.join('\n');
            uploadArea.style.display = 'none';
            programSettings.style.display = 'block';
        }
        
        function initializeMachine() {
            // Parse inputs
            machine.code_start = parseInt(pcStartInput.value, 16);
            const pcEnd = parseInt(pcEndInput.value, 16);
            machine.stack_bot = parseInt(spStartInput.value, 16) - 1024; // Allocate 1KB stack
            machine.stack_top = parseInt(spStartInput.value, 16);
            
            // Initialize registers
            machine.registers.fill(0);
            machine.used.fill(false);
            machine.registers[31] = machine.stack_top; // sp
            machine.registers[32] = machine.code_start; // pc
            
            // Initialize stack
            machine.stack = new Array(128).fill(0);
            
            // Reset current instruction
            machine.current_instruction = 0;
            
            // Update UI
            programSettings.style.display = 'none';
            updateUI();
        }
        
        function updateUI() {
            // Update code display with highlighting
            const currentPC = machine.registers[32];
            const currentLine = (currentPC - machine.code_start) / 4;
            
            codeDisplay.innerHTML = machine.code.map((line, index) => {
                const addr = (machine.code_start + index * 4).toString(16).toUpperCase().padStart(4, '0');
                if (index === currentLine) {
                    return `<div class="highlight">${addr}: ${line}</div>`;
                }
                return `<div>${addr}: ${line}</div>`;
            }).join('');
            
            // Update register display
            registerDisplay.innerHTML = '';
            for (let i = 0; i < 33; i++) {
                const regDiv = document.createElement('div');
                let regName;
                
                if (i === 31) regName = 'sp';
                else if (i === 32) regName = 'pc';
                else regName = `x${i}`;
                
                if (machine.used[i]) {
                    regDiv.classList.add('used');
                }
                
                regDiv.textContent = `${regName}: 0x${machine.registers[i].toString(16).padStart(8, '0')}`;
                registerDisplay.appendChild(regDiv);
            }
            
            // Update memory display
            memoryDisplay.innerHTML = '';
            for (let i = 0; i < machine.stack.length; i++) {
                const addr = machine.stack_bot + i * 8;
                const memDiv = document.createElement('div');
                memDiv.textContent = `0x${addr.toString(16).padStart(8, '0')}: 0x${machine.stack[i].toString(16).padStart(16, '0')}`;
                memoryDisplay.appendChild(memDiv);
            }
        }
        
        function parseInstruction(instruction) {
            // Simple instruction parser
            const parts = instruction.split(/[,\s]+/).filter(p => p);
            const opcode = parts[0];
            const args = parts.slice(1);
            
            return { opcode, args };
        }
        
        function executeInstruction(instr) {
            const { opcode, args } = parseInstruction(instr);
            
            // Get register numbers
            const getRegNum = (reg) => {
                if (reg === 'sp') return 31;
                if (reg === 'pc') return 32;
                if (reg === 'xzr') return 33; // Zero register
                return parseInt(reg.substring(1));
            };
            
            // Get immediate value
            const getImm = (imm) => {
                if (imm.startsWith('#')) {
                    imm = imm.substring(1);
                }
                return parseInt(imm);
            };
            
            // Mark register as used
            const markUsed = (reg) => {
                const regNum = getRegNum(reg);
                if (regNum >= 0 && regNum < 33) {
                    machine.used[regNum] = true;
                }
            };
            
            // Execute based on opcode
            switch (opcode) {
                case 'add':
                    const rd = getRegNum(args[0]);
                    const rn = getRegNum(args[1]);
                    
                    // Handle immediate
                    if (args[2].startsWith('#')) {
                        const imm = getImm(args[2]);
                        machine.registers[rd] = machine.registers[rn] + imm;
                    } else {
                        const rm = getRegNum(args[2]);
                        machine.registers[rd] = machine.registers[rn] + machine.registers[rm];
                    }
                    
                    markUsed(args[0]);
                    break;
                    
                case 'sub':
                    const rd_sub = getRegNum(args[0]);
                    const rn_sub = getRegNum(args[1]);
                    
                    // Handle immediate
                    if (args[2].startsWith('#')) {
                        const imm = getImm(args[2]);
                        machine.registers[rd_sub] = machine.registers[rn_sub] - imm;
                    } else {
                        const rm = getRegNum(args[2]);
                        machine.registers[rd_sub] = machine.registers[rn_sub] - machine.registers[rm];
                    }
                    
                    markUsed(args[0]);
                    break;
                    
                case 'lsl':
                    const rd_lsl = getRegNum(args[0]);
                    const rn_lsl = getRegNum(args[1]);
                    const shift = getImm(args[2]);
                    
                    machine.registers[rd_lsl] = machine.registers[rn_lsl] << shift;
                    markUsed(args[0]);
                    break;
                    
                case 'lsr':
                    const rd_lsr = getRegNum(args[0]);
                    const rn_lsr = getRegNum(args[1]);
                    const shift_amount = getImm(args[2]);
                    
                    machine.registers[rd_lsr] = machine.registers[rn_lsr] >> shift_amount;
                    markUsed(args[0]);
                    break;
                    
                case 'str':
                    const rt_str = getRegNum(args[0]);
                    
                    // Extract address calculation
                    const addr_str = args[1].substring(1, args[1].length - 1);
                    const addr_parts = addr_str.split(/[,\s]+/);
                    
                    let base_reg = getRegNum(addr_parts[0]);
                    let offset = 0;
                    let pre_index = false;
                    
                    if (addr_parts.length > 1) {
                        if (addr_parts[1].startsWith('#')) {
                            offset = getImm(addr_parts[1]);
                            pre_index = addr_str.includes('!');
                        }
                    }
                    
                    // Calculate effective address
                    let effective_addr;
                    if (pre_index) {
                        // Pre-indexed addressing
                        machine.registers[base_reg] += offset;
                        effective_addr = machine.registers[base_reg];
                    } else {
                        // Post-indexed or offset addressing
                        effective_addr = machine.registers[base_reg] + offset;
                        
                        // For post-indexed, update the base register after
                        if (addr_str.includes(']') && addr_str.includes(',')) {
                            machine.registers[base_reg] += offset;
                        }
                    }
                    
                    // Store to memory
                    const stack_index = (effective_addr - machine.stack_bot) / 8;
                    if (stack_index >= 0 && stack_index < machine.stack.length) {
                        machine.stack[stack_index] = machine.registers[rt_str];
                    }
                    break;
                    
                case 'ldr':
                    const rt_ldr = getRegNum(args[0]);
                    
                    // Extract address calculation
                    const addr_ldr = args[1].substring(1, args[1].length - 1);
                    const addr_parts_ldr = addr_ldr.split(/[,\s]+/);
                    
                    let base_reg_ldr = getRegNum(addr_parts_ldr[0]);
                    let offset_ldr = 0;
                    let pre_index_ldr = false;
                    
                    if (addr_parts_ldr.length > 1) {
                        if (addr_parts_ldr[1].startsWith('#')) {
                            offset_ldr = getImm(addr_parts_ldr[1]);
                            pre_index_ldr = addr_ldr.includes('!');
                        }
                    }
                    
                    // Calculate effective address
                    let effective_addr_ldr;
                    if (pre_index_ldr) {
                        // Pre-indexed addressing
                        machine.registers[base_reg_ldr] += offset_ldr;
                        effective_addr_ldr = machine.registers[base_reg_ldr];
                    } else {
                        // Post-indexed or offset addressing
                        effective_addr_ldr = machine.registers[base_reg_ldr];
                        
                        // For post-indexed, update the base register after
                        if (addr_ldr.includes(']') && addr_ldr.includes(',')) {
                            machine.registers[base_reg_ldr] += offset_ldr;
                        }
                    }
                    
                    // Load from memory
                    const stack_index_ldr = (effective_addr_ldr - machine.stack_bot) / 8;
                    if (stack_index_ldr >= 0 && stack_index_ldr < machine.stack.length) {
                        machine.registers[rt_ldr] = machine.stack[stack_index_ldr];
                        markUsed(args[0]);
                    }
                    break;
                    
                case 'cmp':
                    const rn_cmp = getRegNum(args[0]);
                    
                    // Set flags based on comparison (store in machine state)
                    if (args[1].startsWith('#')) {
                        const imm = getImm(args[1]);
                        machine.zero_flag = (machine.registers[rn_cmp] === imm);
                    } else {
                        const rm = getRegNum(args[1]);
                        machine.zero_flag = (machine.registers[rn_cmp] === machine.registers[rm]);
                    }
                    break;
                    
                case 'beq':
                    // Branch if equal (zero flag set)
                    if (machine.zero_flag) {
                        const branch_offset = getImm(args[0]);
                        machine.registers[32] += branch_offset - 4; // -4 to account for the PC increment after this
                    }
                    break;
                    
                case 'b':
                    // Unconditional branch
                    const branch_offset_b = getImm(args[0]);
                    machine.registers[32] += branch_offset_b - 4; // -4 to account for the PC increment after this
                    break;
                    
                // Add more instructions as needed
            }
            
            // Increment PC by default (4 bytes per instruction)
            machine.registers[32] += 4;
        }
        
        function stepExecution() {
            if (!machine.code || machine.code.length === 0 || 
                machine.current_instruction >= machine.code.length) {
                return;
            }
            
            const currentPC = machine.registers[32];
            const currentLine = (currentPC - machine.code_start) / 4;
            
            if (currentLine < 0 || currentLine >= machine.code.length) {
                return;
            }
            
            executeInstruction(machine.code[currentLine]);
            machine.current_instruction = (machine.registers[32] - machine.code_start) / 4;
            
            updateUI();
        }
        
        function resetExecution() {
            stopExecution();
            initializeMachine();
        }
        
        function runExecution() {
            if (machine.running) return;
            
            machine.running = true;
            runButton.disabled = true;
            stopButton.disabled = false;
            
            machine.runInterval = setInterval(() => {
                stepExecution();
                
                // Check if we've reached the end
                if (machine.current_instruction >= machine.code.length) {
                    stopExecution();
                }
            }, 500); // Run at a speed where users can see what's happening
        }
        
        function stopExecution() {
            if (machine.runInterval) {
                clearInterval(machine.runInterval);
            }
            
            machine.running = false;
            runButton.disabled = false;
            stopButton.disabled = true;
        }
        
        function setUserValue() {
            if (inputTypeSelect.value === 'register') {
                const regNum = parseInt(regInput.value);
                const value = valInput.value.startsWith('0x') ? 
                    parseInt(valInput.value, 16) : parseInt(valInput.value);
                
                if (!isNaN(regNum) && !isNaN(value) && regNum >= 0 && regNum <= 32) {
                    machine.registers[regNum] = value;
                    machine.used[regNum] = true;
                    updateUI();
                } else {
                    alert('Please enter valid register number and value');
                }
            } else {
                const address = memInput.value.startsWith('0x') ? 
                    parseInt(memInput.value, 16) : parseInt(memInput.value);
                const value = valInput.value.startsWith('0x') ? 
                    parseInt(valInput.value, 16) : parseInt(valInput.value);
                
                if (!isNaN(address) && !isNaN(value)) {
                    const stackIndex = (address - machine.stack_bot) / 8;
                    if (stackIndex >= 0 && stackIndex < machine.stack.length) {
                        machine.stack[stackIndex] = value;
                        updateUI();
                    } else {
                        alert('Address out of range');
                    }
                } else {
                    alert('Please enter valid memory address and value');
                }
            }
            
            // Clear inputs
            regInput.value = '';
            memInput.value = '';
            valInput.value = '';
        }
        
        // Initialize register display
        updateUI();
    </script>
</body>
</html> 